<?php

declare(strict_types=1);

namespace davekok\parser;

use Generator;
use IteratorAggregate;

/**
 * Generator of files for parser.
 *
 * Please note the generator will not save the files itself.
 * Instead it yields what should be saved.
 *
 * Simple implementation to save the generated files:
 *
 *     foreach (new ParserGenerator(new ParserReflection(MyParser::class)) as $phpFile) {
 *         file_put_contents($phpFile->name, (string)$phpFile);
 *     }
 *
 */
class ParserGenerator implements IteratorAggregate
{
    private int $indentLevel = 0;

    public readonly string|false $namespace;
    public readonly string $name;
    public readonly string|false $comment;
    public readonly string $typeName;
    public readonly string $ruleName;
    public readonly string $tokenName;
    public readonly string $lexarName;
    public readonly string $stitcherName;
    public readonly string $dirname;
    public readonly PhpCodeStyle $style;

    public function __construct(
        public readonly ParserReflection $reflection,
        string|false|null $namespace = null,
        string|null $name = null,
        bool $comment = true,
        string|null $dirname = null,
        string|null $typeName = null,
        string|null $ruleName = null,
        string|null $tokenName = null,
        string|null $lexarName = null,
        string|null $stitcherName = null,
        PhpCodeStyle $style = new PhpCodeStyle(),
    ) {
        $this->namespace = $namespace ?? ($this->reflection->class->inNamespace() ? $this->reflection->class->getNamespaceName() : false);
        $this->name = $name ?? $this->reflection->name ?? $this->reflection->class->getShortName();
        $this->dirname = $dirname ?? dirname($this->reflection->class->getFileName() ?: throw new ParserReflectionException("Parser has no filename."));
        $this->typeName = $typeName ?? ($this->name . "Type");
        $this->ruleName = $ruleName ?? ($this->name . "Rule");
        $this->tokenName = $tokenName ?? ($this->name . "Token");
        $this->lexarName = $lexarName ?? ($this->name . "Lexar");
        $this->stitcherName = $stitcherName ?? ($this->name . "Stitcher");
        $this->style = $style;
        $this->comment = $comment
            ? "Generated for {$this->reflection->class->name}\nGenerated by  " . __CLASS__ . "\nGenerated on  " . date("Y-m-d H:i:s")
            : false;
    }

    public function getIterator(): Generator
    {
        yield $this->type($this->reflection->types);
        foreach ($this->sortByContext($this->reflection->rules) as $context => $rules) {
            yield $this->rule($context, $rules);
        }
        yield $this->token();
        if ($this->reflection->lexar && !file_exists("$this->dirname/$this->lexarName.php")) {
            yield $this->lexar();
        }
        yield $this->stitcher();
    }

    private function type(array $types): PhpFile
    {
        $file = new PhpFile("$this->dirname/$this->typeName.php", $this->style);
        $enum = $file->namespace($this->namespace)
            ->enum($this->typeName)->stringBacked()->implements(TypeEnum::class)
                ->comment($this->comment)
                ->cases($this->cases($types))
                ->public()->method("id")->returns("int")
                    ->body("return match (\$this) {\n{$this->matches($types, "id")}\n};")
                ->public()->method("name")->returns("string")
                    ->body("return match (\$this) {\n{$this->matches($types, "name")}\n};")
                ->public()->method("key")->returns("string")
                    ->body("return \$this->value;")
                ->public()->method("pattern")->returns("string")
                    ->body("return match (\$this) {\n{$this->matches($types, "pattern")}\n};")
                ->public()->method("input")->returns("bool")
                    ->body("return match (\$this) {\n{$this->matches($types, "input")}\n};")
                ->public()->method("output")->returns("bool")
                    ->body("return match (\$this) {\n{$this->matches($types, "output")}\n};")
                ->public()->method("precedence")->returns("int")
                    ->body("return match (\$this) {\n{$this->matches($types, "precedence")}\n};");
        return $file;
    }

    private function rule(string $postfix, array $rules): PhpFile
    {
        return (new PhpFile("$this->dirname/$this->ruleName$postfix.php", $this->style))
            ->namespace($this->namespace)
            ->enum($this->ruleName . $postfix)->stringBacked()->implements(RuleEnum::class)
                ->comment($this->comment)
                ->cases($this->cases($rules))
                ->public()->method("name")->returns("string")
                    ->body("return match (\$this) {\n{$this->matches($rules, "name")}\n};")
                ->public()->method("key")->returns("string")
                    ->body("return \$this->value;")
                ->public()->method("rule")->returns("string")
                    ->body("return match (\$this) {\n{$this->matches($rules, "rule")}\n};")
                ->public()->method("precedence")->returns("int")
                    ->body("return match (\$this) {\n{$this->matches($rules, "precedence")}\n};")
                ->end();
    }

    private function token(): PhpFile
    {
        return (new PhpFile("$this->dirname/$this->tokenName.php", $this->style))
            ->namespace($this->namespace)
            ->class($this->tokenName)->implements(Token::class)
                ->comment($this->comment)
                ->public()->constructor()
                    ->public()->readonly()->param("type")->type($this->namespace."\\".$this->typeName)
                    ->public()->readonly()->param("value")->type($this->reflection->valueType)->default(null)
                    ->body()
                ->end();
    }

    private function lexar(): PhpFile
    {
        return (new PhpFile("$this->dirname/$this->lexarName.php"))
            ->namespace($this->namespace)
            ->trait($this->lexarName)
                ->comment("Lexical analyzer\n\n".$this->comment)
                ->private()->method("lex")->returns(Generator::class)
                    ->param("input")->type("iterable")
                    ->body("// TODO: implement lexar")
                ->end();
    }

    private function stitcher(): PhpFile
    {
        $file = new PhpFile("$this->dirname/$this->stitcherName.php", $this->style);
        $file->namespace($this->namespace);

        $trait = $file->trait($this->stitcherName)
            ->comment($this->comment)
            ->private()->property("parserContext")->type("string")->default($this->reflection->defaultContext ?? "")
            ->private()->method("setParserContext")->returns("void")
                ->param("context")->type("string|null")
                ->body("\$this->parserContext = \$context;")
            ->private()->method("getParserContext")->returns("string|null")
                ->body("return \$this->parserContext;");

        if ($this->reflection->lexar) {
            $trait->public()->method("parse")->returns(Generator::class)
                ->param("input")->type("string|iterable")
                ->body("foreach (\$this->parseTokens(\$this->lex(is_string(\$input) ? [\$input] : \$input)) as \$token) {\n"
                    . "yield \$token->value;\n"
                . "};");
        }

        $trait->private()->method("findRule")->returns("$this->namespace\\$this->ruleName|null")
            ->param("key")->type("string")
            ->body($this->findRuleBody($this->reflection->rules));

        $trait->private()->method("reduce")->returns(Token::class)
            ->param("key")->type(RuleEnum::class)
            ->param("tokens")->type("array")
            ->body("return match (\$key) {\n{$this->reducers()}\n};");

        return $file;
    }

    private function cases(iterable $cases): Generator
    {
        foreach ($cases as $case) {
            $binstr = "";
            $l = strlen($case->key);
            for ($i = 0; $i < $l; ++$i) {
                $c = ord($case->key[$i]);
                $binstr .= match (true) {
                    $c < 0x20 || $c > 0x7E => sprintf('\x%02X', $c),
                    default => chr($c),
                };
            }
            yield $case->name => $binstr;
        }
    }

    private function matches(array $entries, string $property): string
    {
        $lines = "";
        foreach ($entries as $entry) {
            $value = $entry->$property;
            $lines .= "self::$entry->name => " . match (true) {
                is_string($value) => "\"" . addslashes($value) . "\"",
                is_int($value) => (string)$value,
                $value === true => "true",
                $value === false => "false",
            } . ",\n";
        }
        return rtrim($lines);
    }

    private function findRuleBody(array $rules): string
    {
        $body = "return match (\$this->parserContext) {\n";
        foreach ($this->getContexts($rules) as $context) {
            $body .= "\"$context\" => $this->ruleName$context::tryFrom(\$key),\n";
        }
        $body .= "default => throw new \davekok\parser\ParserException(\"Invalid parser context \$this->parserContext.\"),\n";
        $body .= "};\n";
        return $body;
    }

    private function reducers(): string
    {
        $lines = "";
        foreach ($this->reflection->rules as $rule) {
            $parts = explode(" ", $rule->rule);
            $lines .= "$this->ruleName::$rule->name => new {$this->tokenName}({$this->typeName}::{$rule->type}, \$this->{$rule->reducer->name}(";
            $comma = 0;
            foreach ($rule->reducer->getParameters() as $parameter) {
                if ($comma++) $lines .= ", ";
                $lines .= "\$tokens[{$rule->binding[$parameter->name]}]->value";
            }
            $lines .= ")),\n";
        }
        return rtrim($lines);
    }

    private function getContexts(array $items): array
    {
        $contexts = [];
        foreach ($items as $item) {
            foreach ($item->context as $context) {
                if (!in_array($context, $contexts)) {
                    $contexts[] = $context;
                }
            }
        }
        sort($contexts);
        return $contexts;
    }

    private function sortByContext(array $items): array
    {
        $contexts = [];
        foreach ($items as $item) {
            foreach ($item->context as $context) {
                $contexts[$context][] = $item;
            }
        }
        return $contexts;
    }
}
