<?php

declare(strict_types=1);

namespace davekok\parser;

use Generator;
use IteratorAggregate;

/**
 * Generator of files for parser.
 *
 * Please note the generator will not save the files itself.
 * Instead it yields what should be saved.
 *
 * Simple implementation to save the generated files:
 *
 *     foreach (new ParserGenerator(new ParserReflection(MyParser::class)) as $phpFile) {
 *         file_put_contents($phpFile->name, (string)$phpFile);
 *     }
 *
 */
class ParserGenerator implements IteratorAggregate
{
    private int $indentLevel = 0;

    public readonly string|false $namespace;
    public readonly string $name;
    public readonly string|false $comment;
    public readonly string $typeName;
    public readonly string $ruleName;
    public readonly string $tokenName;
    public readonly string $lexarName;
    public readonly string $stitcherName;
    public readonly string $dirname;
    public readonly PhpCodeStyle $style;

    public function __construct(
        public readonly ParserReflection $reflection,
        string|false|null $namespace = null,
        string|null $name = null,
        bool $comment = true,
        string|null $dirname = null,
        string|null $typeName = null,
        string|null $ruleName = null,
        string|null $tokenName = null,
        string|null $lexarName = null,
        string|null $stitcherName = null,
        PhpCodeStyle $style = new PhpCodeStyle(),
    ) {
        $this->namespace = $namespace ?? ($this->reflection->class->inNamespace() ? $this->reflection->class->getNamespaceName() : false);
        $this->name = $name ?? $this->reflection->name ?? $this->reflection->class->getShortName();
        $this->dirname = $dirname ?? dirname($this->reflection->class->getFileName() ?: throw new Exception("Parser has no filename."));
        $this->typeName = $typeName ?? ($this->name . "Type");
        $this->ruleName = $ruleName ?? ($this->name . "Rule");
        $this->tokenName = $tokenName ?? ($this->name . "Token");
        $this->lexarName = $lexarName ?? ($this->name . "Lexar");
        $this->stitcherName = $stitcherName ?? ($this->name . "Stitcher");
        $this->style = $style;
        $this->comment = $comment
            ? "Generated for {$this->reflection->class->name}\nGenerated by  " . __CLASS__ . "\nGenerated on  " . date("Y-m-d H:i:s")
            : false;
    }

    public function getIterator(): Generator
    {
        yield $this->type();
        yield $this->rule();
        yield $this->token();
        if ($this->reflection->lexar && !file_exists("$this->dirname/$this->lexarName.php")) {
            yield $this->lexar();
        }
        yield $this->stitcher();
    }

    public function type(): PhpFile
    {
        return (new PhpFile("$this->dirname/$this->typeName.php", $this->style))
            ->namespace($this->namespace)
            ->enum($this->typeName)->stringBacked()
                ->comment($this->comment)
                ->cases($this->cases($this->reflection->types))
                ->public()->method("id")->return("int")
                    ->body("return match (\$this) {\n{$this->matches("types", "id")}\n};")
                ->public()->method("name")->return("string")
                    ->body("return match (\$this) {\n{$this->matches("types", "name")}\n};")
                ->public()->method("key")->return("string")
                    ->body("return \$this->value;")
                ->public()->method("text")->return("string")
                    ->body("return match (\$this) {\n{$this->matches("types", "text")}\n};")
                ->public()->method("input")->return("bool")
                    ->body("return match (\$this) {\n{$this->matches("types", "input")}\n};")
                ->public()->method("output")->return("bool")
                    ->body("return match (\$this) {\n{$this->matches("types", "output")}\n};")
                ->public()->method("precedence")->return("int")
                    ->body("return match (\$this) {\n{$this->matches("types", "precedence")}\n};")
                ->end();
    }

    private function cases(iterable $cases): Generator
    {
        foreach ($cases as $case) {
            $binstr = "";
            $l = strlen($case->key);
            for ($i = 0; $i < $l; ++$i) {
                $c = ord($case->key[$i]);
                $binstr .= match (true) {
                    $c < 0x20 || $c > 0x7E => sprintf('\x%02X', $c),
                    default => chr($c),
                };
            }
            yield $case->name => $binstr;
        }
    }

    public function rule(): PhpFile
    {
        return (new PhpFile("$this->dirname/$this->ruleName.php", $this->style))
            ->namespace($this->namespace)
            ->enum($this->ruleName)->stringBacked()
                ->comment($this->comment)
                ->cases($this->cases($this->reflection->rules))
                ->public()->method("name")->return("string")
                    ->body("return match (\$this) {\n{$this->matches("rules", "name")}\n};")
                ->public()->method("key")->return("string")
                    ->body("return \$this->value;")
                ->public()->method("text")->return("string")
                    ->body("return match (\$this) {\n{$this->matches("rules", "text")}\n};")
                ->public()->method("precedence")->return("int")
                    ->body("return match (\$this) {\n{$this->matches("rules", "precedence")}\n};")
                ->end();
    }

    private function matches(string $collection, string $property): string
    {
        $lines = "";
        foreach ($this->reflection->$collection as $entry) {
            $value = $entry->$property;
            $lines .= "self::$entry->name => " . match (true) {
                is_string($value) => "\"" . addslashes($value) . "\"",
                is_int($value) => (string)$value,
                $value === true => "true",
                $value === false => "false",
            } . ",\n";
        }
        return rtrim($lines);
    }

    public function token(): PhpFile
    {
        return (new PhpFile("$this->dirname/$this->tokenName.php", $this->style))
            ->namespace($this->namespace)
            ->class($this->tokenName)->implements(Token::class)
                ->comment($this->comment)
                ->public()->constructor()
                    ->public()->readonly()->arg("type")->type($this->namespace."\\".$this->typeName)
                    ->public()->arg("value")->type($this->reflection->valueType)->default(null)
                    ->body()
                ->end();
    }

    public function lexar(): PhpFile
    {
        return (new PhpFile("$this->dirname/$this->lexarName.php"))
            ->namespace($this->namespace)
            ->trait($this->lexarName)
                ->comment("Lexical analyzer\n\n".$this->comment)
                ->private()->method("lex")->return(Generator::class)
                    ->arg("input")->type("iterable")
                    ->body("// TODO: implement lexar")
                ->end();
    }

    public function stitcher(): PhpFile
    {
        $file = new PhpFile("$this->dirname/$this->stitcherName.php", $this->style);
        $file->namespace($this->namespace);

        $trait = $file->trait($this->stitcherName);
        $trait->comment($this->comment);

        if ($this->reflection->lexar) {
            $trait->public()->method("parse")->return(Generator::class)
                ->arg("input")->type("string|iterable")
                ->body("yield from \$this->parseTokens(\$this->lex(is_string(\$input) ? [\$input] : \$input));");
        }

        $trait->private()->method("findRule")->return("$this->namespace\\$this->ruleName|null")
            ->arg("key")->type("string")
            ->body("return $this->ruleName::tryFrom(\$key);");

        $trait->private()->method("reduce")->return(Token::class)
            ->arg("key")->type("$this->namespace\\$this->ruleName")
            ->arg("tokens")->type("array")
            ->body("return match (\$key) {\n{$this->reducers()}\n};");

        return $file;
    }

    private function reducers(): string
    {
        $lines = "";
        foreach ($this->reflection->rules as $rule) {
            $lines .= "$this->ruleName::$rule->name => new {$this->tokenName}({$this->typeName}::{$rule->type}, \$this->{$rule->reducer->name}(";
            $i = 0;
            foreach ($rule->reducer->getParameters() as $parameter) {
                if ($i++) $lines .= ", ";
                if (preg_match("/([1-9][0-9]*)?$/", $parameter->name, $matches) === 1) {
                    $tokenIndex = ((int)$matches[1]) - 1;
                    $lines .= "\$tokens[$tokenIndex]->value";
                }
            }
            $lines .= ")),\n";
        }
        return rtrim($lines);
    }
}
